<?php
namespace Sandstorm\Fuzzer\Command;

/*                                                                        *
 * This script belongs to the TYPO3 Flow package "Sandstorm.Fuzzer".      *
 *                                                                        *
 *                                                                        */

use TYPO3\Flow\Annotations as Flow;

/**
 * Code Coverage helpers for working with Functional Tests, merging code coverage,
 * and rendering it.
 *
 * @Flow\Scope("singleton")
 */
class CodeCoverageCommandController extends \TYPO3\Flow\Cli\CommandController {

	/**
	 * @Flow\Inject
	 * @var \TYPO3\Flow\Package\PackageManagerInterface
	 */
	protected $packageManager;

	/**
	 * Convert (and optionally filter) code coverage data generated by functional tests,
	 * such that file references inside point not to the code cache inside Data/Temporary/....,
	 * but to the Classes/ directory of the packages.
	 *
	 * <b>Example Usage:</b>
	 * phpunit -c Build/BuildEssentials/FunctionalTests.xml --coverage-php Build/Reports/RawFunctionalTestCoverageReport.php
	 * ./flow codeCoverage:convert Build/Reports/RawFunctionalTestCoverageReport.php Build/Reports/FunctionalTestCoverageReport.php --packages 'Your.Packages,Separated.By.Comma'
	 *
	 * The "--packages" argument is optional; but using it results in a huge speed boost;
	 * as only the classes from the specified packages are included in the coverage result.
	 *
	 * @param string $codeCoverageFile Path to the code coverage file generated with "--coverage-php" of phpunit.
	 * @param string $outFile Path to the converted code coverage file
	 * @param string $packages The comma-separated list of packages to filter for. These packages must be installed here.
	 * @param string $context The Flow context which has been used during the functional test run. Only needs to be modified if tests are ran in a special context.
	 */
	public function convertCommand($codeCoverageFile, $outFile, $packages = '*', $context = 'Testing') {

		// Load $packages which should be taken into account while conversion
		$packageKeys = $packages;
		if ($packageKeys === '*') {
			$packages = $this->packageManager->getActivePackages();
		} else {
			$packages = array();
			foreach (\TYPO3\Flow\Utility\Arrays::trimExplode(',', $packageKeys) as $packageKey) {
				$packages[] = $this->packageManager->getPackage($packageKey);
			}
		}

		// For all $packages which should be used, build up a "cache-file-name" -> "real-file-name" mapping.
		$reverseIndexOfCacheFileNamesToClassFiles = array();
		foreach ($packages as $package) {
			/* @var $package \TYPO3\Flow\Package\PackageInterface */
			foreach ($package->getClassFiles() as $className => $fileName) {
				$cacheFileName = str_replace('\\', '_', $className);
				$reverseIndexOfCacheFileNamesToClassFiles[$cacheFileName] = $package->getPackagePath() . $fileName;
			}
		}

		// Modify the coverage report
		/* @var $coverage \Php_CodeCoverage */
		$coverage = unserialize(file_get_contents($codeCoverageFile));
		$coverageData = $coverage->getData();
		$baseDirectoryLength = strlen(FLOW_PATH_ROOT . 'Data/Temporary/' . $context . '/Cache/Code/Flow_Object_Classes/');

		$adjustedCoverageData = array();
		foreach ($coverageData as $fullCacheFileName => $coverageDataForFile) {
			$shortCacheFileName = substr($fullCacheFileName, $baseDirectoryLength, -4);

			if (isset($reverseIndexOfCacheFileNamesToClassFiles[$shortCacheFileName])) {
				$classFileInPackage = $reverseIndexOfCacheFileNamesToClassFiles[$shortCacheFileName];
				$numberOfLinesOfFile = count(file($classFileInPackage));

				if (isset($adjustedCoverageData[$classFileInPackage])) {
					throw new \Sandstorm\Fuzzer\Exception('Coverage data already found for class file "' . $classFileInPackage . '". This should never happen; so we do not override it. It is probably a bug in Fuzzer.', 1367238729);
				}
				$adjustedCoverageData[$classFileInPackage] = array();

				foreach ($coverageDataForFile as $lineNumber => $coveredBy) {
					if ($lineNumber <= $numberOfLinesOfFile) {
						$adjustedCoverageData[$classFileInPackage][$lineNumber] = $coveredBy;
					}
				}
			}
		}

		// Save the new coverage report
		$adjustedCoverage = new PhpunitCodeCoverage();
		$adjustedCoverage->setData($adjustedCoverageData);
		$adjustedCoverage->setTests($coverage->getTests());

		file_put_contents($outFile, serialize($adjustedCoverage));
	}

	/**
	 * Merge two PHPUnit coverage reports (generated with --coverage-php) into one.
	 *
	 * @param string $coverage1 Path towards the first coverage report
	 * @param string $coverage2 Path towards the second coverage report
	 * @param string $outFile Path towards the merged coverage report
	 */
	public function mergeCommand($coverage1, $coverage2, $outFile) {
		$coverage1Contents = unserialize(file_get_contents($coverage1));
		$coverage2Contents = unserialize(file_get_contents($coverage2));

		$coverage1Contents->merge($coverage2Contents);
		file_put_contents($outFile, serialize($coverage1Contents));
	}

	/**
	 * Render a PHP coverage report at location $coverage in the specified $format
	 * to the location specified by $out.
	 *
	 * @param string $coverage Path towards the (php) coverage report (generated with --coverage-PHP)
	 * @param string $out Path towards the resulting directory
	 * @param string $format The format to output
	 */
	public function renderCommand($coverage, $out, $format = 'html') {
		$coverage = unserialize(file_get_contents($coverage));

		if ($format === 'html') {
			$writer = new \PHP_CodeCoverage_Report_HTML;
		} elseif ($format === 'clover') {
			$writer = new \PHP_CodeCoverage_Report_Clover();
		} else {
			$this->outputFormatted('The format "' . $format . '" is not supported by codeCoverage:render. Please use either "html" (default) or "clover".');
			$this->quit(1);
		}

		$writer->process($coverage, $out);
	}
}
?>